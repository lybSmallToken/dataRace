### 代码介绍
1.xgb框架 -> xgb.py + genSamples.py + genFeatures.py + genLibs.py

2.lgb框架 -> lgb.py + genSamples.py + genFeatures.py + genLibs.py

3.knn思路做推荐 -> knn.py

4.stacking框架 -> stacking.py

5.画分布直方图 -> distance_hist.py

6.多进程加速 -> mouseClick.py(借鉴文超的代码)

7.gbdt产生特征 -> gbdt_gen_features.py

8.模型调参 -> genLibs.py -> def tiaocan()

9.模型结果融合 -> avg2.py
##### 总体框架
&emsp;&emsp;根据历史记录+规则构造训练集和测试集， 使用单模型(lightGBM)测试特征好坏(主要通过绘制 feature 重要性
条形图),最后使用 xgboost+lightGBM+gbdt+RF+stacking+LR 模型融合的方式预测

### 建模思路
&emsp;&emsp;首先这个问题不能使用多分类的思路解决，因为多分类的label过多。所以想到把原问题转化成一个二分类问题，具体的做法就是首先构造可能的目的地备选，然后对于每一个备选来说，相当于是一个二分类问题。 </br>
&emsp;&emsp;在构造备选的时候又会有一个十分关键的问题，就是如何同时保证覆盖率与召回率。所谓的覆盖率是指：构造的备选中是否含有真实的目的地。所谓的召回率是指：多少个备选中才能有一个真实目的地的平均比例。在这个问题中，这两点都十分重要。在刚刚结束的商铺比赛中，我看到第一名的解法是更加偏向于覆盖率，基本上进行很少的条件过滤。在这个问题上，智者见智，在不过滤的情况下，需要很高的设备要求，因为在这种情况下，模型无疑需要通过更加高维的特征来学习到真实的目的地！
##### 我是如何构造备选的
在这个比赛中，我主要从6个角度来构造备选： </br>
1.用户去过的终点 </br>
2.用户出发过的起点 </br>
3.起点对应的终点 </br>
4.起点的neighbor对应的终点(后加，开始没有想到)</br>
5.bikeid的leak地点(对于同一个bikeid，其上一条记录的终点很可能是下一条记录的起点) </br>
6.userid的leak地点(对于同一个userid，其上一条记录的终点很可能是下一条记录的起点)
##### 过滤异常样本
&emsp;&emsp;在上面构造备选的过程中，有一些样本是异常的，比如：骑行距离过远、骑行速度过快、骑行方向多变。对上面的样本进行过滤。
除此之外，我们对数据进行探索之后发现，在用户的骑行记录中没有正西方向的记录，所以后期把正西方向的样本也进行了过滤处理。
##### 特征工程
主要的特征可以参考下面的特征重要性图，有：bikeLeak,userLeak,频次,概率,熵,距离,方向,滑窗,AutoGBDT,时间,聚类等特征。

![](FeatureImportance.jpg)

对于特征重要性来说，有两种类型，第一种类型是根据使用本特征的分裂节点次数(本图)，还有一种根据信息增益的大小。
