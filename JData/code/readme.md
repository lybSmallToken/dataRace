### 代码模块介绍
#### train.py  -> 使用不同的模型进行训练，线下验证
#### JDataScore.py -> 模拟线上的评测函数，完成了线上线下分数基本一致的效果
#### gen_feat2.py -> 产生不同的特征
#### others.py -> 为gen_feat2.py服务，产生特征

### 依赖环境
  #### python2.7,pandas,numpy,sklearn,xgboost 
### 建模思路框架
#### 构造训练集和测试集:
##### 训练集的构造
&emsp;&emsp;考虑到较为远的信息参考价值没有那么明显(比如：某用户近一个月的行为会对接下来5天是否发生购买行为产生较大的影响，而时间更远的行为的指导意义不大)，所以采用了一个月的数据作为训练集，也就是2016-03-10 至 2016-04-11的数据作为训练集，选取和需要预测时间长度相同的时间段 2016-04-11 至 2016-04-16的数据对训练集中的记录打label。 </br>
&emsp;&emsp;这里需要注意，不可以只打第8类(P子集)的label,因为用户的购买不同商品的行为是具有相似性的，如果只是考虑第8类商品，会使样本十分不均衡！
##### 测试集的构造
&emsp;&emsp;选取比赛需要预测的时间点前一个月的数据构造测试集，也就是2016-03-15 至 2016-04-16的数据.然后对其中有行为的记录进行预测，过滤出第8类商品作为提交的答案.

#### 特征工程
##### 用户特征 ： def get_basic_user_feat() </br>
年龄 -> one-hot编码，性别 -> one-hot编码，用户等级 -> ont-hot编码
##### 商品特征 ： def get_basic_product_feat() </br>
用户的三种属性，a1,a2,a3 -> one-hot编码
##### 用户-商品对行为特征 ：def get_action_feat() </br>
用户行为 -> one-hot编码，巧妙运用编码之后求和累计用户-商品对的行为次数
##### 商品行为特征 : def get_action_feat_sku() </br>
用户行为 -> one-hot编码, 随后仅统计sku_id的行为累计次数，也即使用groupby('sku_id').sum()
##### 用户行为特征 : def get_action_feat_usr() </br>
用户行为 -> one-hot编码, 随后仅统计user_id的行为累计次数，也即使用groupby('user_id').sum()
##### 衰减特征 : def get_accumulate_action_feat() </br>
用户行为的累计数按照时间进行衰减处理
##### 商品评论特征 ：def get_comments_product_feat() </br>
差评率，好评率，评论数目等级 -> one-hot编码
##### 用户行为购买转化率特征 ：def get_accumulate_user_feat() </br>
对于用户而言，不同用户行为下单转化率特征
##### 商品行为购买转化率特征 ：def get_accumulate_product_feat() </br>
对于商品而言，不同用户行为下单转化率特征
##### 滑窗特征 ：def make_train_set(),def make_test_set() </br>
对于上面的特征使用不同的时间窗口获得不同的统计特征值

#### 亮点与思考
亮点1：使用滑窗的统计特征 </br>
亮点2：由于最近的行为的影响更大，所以使用了统计量随时间衰减的特征 </br>
亮点3：对用户行为特征one-hot编码之后，使得行为次数的统计变得十分方便 </br>
亮点4: 构造的线下验证集与线上基本一致，使得线上线下同增同减 </br>
思考1：当时的瓶颈应该在覆盖率上，也就是选取一个月的数据作为测试集，覆盖率不够，导致实际发生购买行为的样本根本不在测试集中出现，就更谈不上准确的预测了 </br>
思考2：这个问题是一个样本不均衡的问题，也就是正样本的数量不多，由于是第一个比赛，没有想到这个问题 </br>
总的来说，这次的比赛收获还是很多的，熟练使用了pandas，numpy以及各种常见的工具~
